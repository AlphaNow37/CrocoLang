import marshal
from pathlib import Path
from os.path import getmtime
from hashlib import sha256
from importlib._bootstrap_external import (_code_to_timestamp_pyc,
                                           _validate_timestamp_pyc,
                                           _pack_uint32,
                                           _unpack_uint32,
                                           cache_from_source)
from types import CodeType

default_pyfile_content = """\
raise NotImplementedError("This file is generated by pycompile, and should not be run directly.")\
"""


"""
Explaination:
initial file (a.custom-extension) is compiled:
    the content of the file is saved in a.cache
cache files (__pychache__/a.cpython-310.pyc.cache):
    256-bit hash of the content of the file                -> if the file is changed, the file will be recompiled
pyc files (__pychache__/a.cpython-310.pyc):
    4b: magic number
    4b: timestamp of the initial files last modification   -> must be equal to pyfile last modification
    4b: size of the code object (not used)
    4b: flags (not used, always 0)
pyfiles (a.py):
    the python files that shouldn't be run directly
"""

def get_pyc_path(path) -> Path:
    """
    :param path: the path to the .py file
    :return: the path of the pyc file
    """
    path = Path(path)
    if path.suffix != ".py":
        path = path.with_suffix(".py")
    return Path(cache_from_source(str(path)))

def get_cache_path(pyc_path=None) -> Path:
    """
    :param pyc_path: the path of the pyc file           -
    :return: the path of the cache file
    """
    return Path(str(pyc_path) + ".cache")

def _is_no_changes(initial_hash: bytes, pyfile_mtime: int, cache_path: Path, pyc_path: Path) -> bool:
    """
    :param initial_hash: the hash of the initial file
    :param pyfile_mtime: the last modification time of the py file
    :param cache_path: the path of the cache file
    :param pyc_path: the path of the pyc file
    :return: if the pyc file is up to date
    """
    with open(cache_path, 'rb') as f:
        cache_hash = f.read(32)
    if cache_hash != initial_hash:
        return False
    with open(pyc_path, 'rb') as f:
        data = f.read(16)
    try:
        _validate_timestamp_pyc(data, pyfile_mtime, None, str(pyc_path), {})
    except ImportError:
        return False
    else:
        return True

def create_file(path, code_object, force_recreate=False, initial_path=None, pyfile_content=default_pyfile_content) -> None:
    """
    :param path: the path to the final .py file
    :param code_object: the code object to dump in the pyc file
    :param force_recreate: if the pyc file should be recreated even if it is up to date
    :param initial_path: the path to the initial file (if None, :param path: will be used)
    :param pyfile_content: the text to write in the py file
    :return: None
    """
    path = Path(path)
    initial_path = Path(initial_path) if initial_path else path

    with initial_path.open('rb') as f:
        initial_hash = sha256(f.read()).digest()

    pyc_path = get_pyc_path(path)
    cache_path = get_cache_path(pyc_path=pyc_path)
    py_path = Path(path.parent) / (path.stem + ".py")

    if not pyc_path.parent.exists():
        pyc_path.parent.mkdir()
    elif (not force_recreate) and pyc_path.exists() and py_path.exists() and cache_path.exists():
        pyfile_mtime = int(getmtime(py_path))
        if _is_no_changes(initial_hash, pyfile_mtime, cache_path, pyc_path):
            print("No changes detected, skipping compilation.")
            return
    with open(py_path, "w") as f:
        f.write(pyfile_content)
    dump_pyc(code_object, pyc_path, path, pycontent=pyfile_content)
    with cache_path.open('wb') as f:
        f.write(initial_hash)

def dump_pyc(code_object, path, py_path, pycontent=None) -> None:
    """
    :param code_object: the code object to dump in the pyc file
    :param path: the path to the final .pyc file
    :param py_path: the path to the python file, to get the last modification time and the len of the source
    :return: None
    """

    ts = int(getmtime(py_path))
    if pycontent is None:
        with open(py_path, 'rb') as f:
            ln = len(f.read())
    else:
        ln = len(pycontent)
    path = Path(path)
    with path.open('wb') as f:
        dumped = marshal.dumps(code_object)
        f.write(_code_to_timestamp_pyc(code_object, ts, ln))
        f.write(dumped)

def load_pyc(path) -> CodeType | None:
    """
    :param path: the path to the .pyc file
    :return: None if the file is not a valid pyc file, else the code object
    """
    py_path = Path(path).parent.parent / (Path(path).stem.split(".", 1)[0] + ".py")
    mtime = int(getmtime(py_path))
    with open(path, 'rb') as f:
        data = f.read()
        try:
            _validate_timestamp_pyc(data, mtime, None, str(path), {})
        except ImportError as e:
            print("Invalid pyc file:", e)
            return None
        else:
            return marshal.loads(data[16:])
